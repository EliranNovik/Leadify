-- Purpose: prevent integer overflow when creating contacts/relationships
-- Updates legacy integer IDs to bigint so we can keep creating leads.

BEGIN;

-- contact_with_lead_info depends on leads_contact.id and lead_leadcontact.contact_id.
-- Drop it temporarily so we can change the underlying column types safely.
DROP VIEW IF EXISTS contact_with_lead_info;

-- 1. leads_contact.id may have reached the 32-bit integer limit.
-- Convert it (and any dependent sequences/defaults) to bigint.
ALTER TABLE leads_contact
  ALTER COLUMN id TYPE bigint USING id::bigint;

-- If there is a default that pulls from a sequence, ensure the sequence matches bigint.
-- Also handle identity columns (which have internal sequences)
DO $$
DECLARE
  seq_name text;
  seq_reg regclass;
  identity_seq_name text;
BEGIN
  -- Check for regular sequence (old-style serial)
  SELECT pg_get_serial_sequence('leads_contact', 'id') INTO seq_name;
  IF seq_name IS NOT NULL THEN
    SELECT to_regclass(seq_name) INTO seq_reg;
    IF seq_reg IS NOT NULL THEN
      EXECUTE format('ALTER SEQUENCE %s AS bigint', seq_reg);
    END IF;
  END IF;
  
  -- Check for identity column sequence (new-style generated by default as identity)
  -- Identity columns use a sequence named: tablename_columnname_seq
  SELECT pg_get_serial_sequence('leads_contact', 'id') INTO identity_seq_name;
  IF identity_seq_name IS NOT NULL AND identity_seq_name != seq_name THEN
    SELECT to_regclass(identity_seq_name) INTO seq_reg;
    IF seq_reg IS NOT NULL THEN
      EXECUTE format('ALTER SEQUENCE %s AS bigint', seq_reg);
    END IF;
  END IF;
END $$;

-- 2. lead_leadcontact references leads_contact.id, so upgrade both columns.
ALTER TABLE lead_leadcontact
  ALTER COLUMN id TYPE bigint USING id::bigint,
  ALTER COLUMN contact_id TYPE bigint USING contact_id::bigint;

-- Ensure the relationship table's sequence is also bigint if it exists.
DO $$
DECLARE
  seq_name text;
  seq_reg regclass;
BEGIN
  SELECT pg_get_serial_sequence('lead_leadcontact', 'id') INTO seq_name;
  IF seq_name IS NOT NULL THEN
    SELECT to_regclass(seq_name) INTO seq_reg;
    IF seq_reg IS NOT NULL THEN
      EXECUTE format('ALTER SEQUENCE %s AS bigint', seq_reg);
    END IF;
  END IF;
END $$;

-- Recreate the contact_with_lead_info view now that the IDs are bigint.
CREATE OR REPLACE VIEW contact_with_lead_info AS
SELECT 
    lc.id as contact_id,
    lc.name as contact_name,
    lc.email,
    lc.phone,
    lc.mobile,
    lc.cdate,
    lc.udate,
    llc.id as relationship_id,
    llc.main,
    llc.lead_id,
    ll.manual_id as lead_number,
    ll.name as lead_name,
    ll.stage,
    ll.category_id
FROM public.leads_contact lc
LEFT JOIN public.lead_leadcontact llc ON lc.id = llc.contact_id
LEFT JOIN public.leads_lead ll ON llc.lead_id = ll.id
ORDER BY llc.lead_id, llc.main DESC, lc.name;

GRANT SELECT ON contact_with_lead_info TO authenticated;

-- 3. Also check and convert leads_lead.id to bigint if it's still integer
-- This is needed because the function uses MAX(leads_lead.id) to generate lead numbers
DO $$
DECLARE
  current_type text;
  seq_name text;
  seq_reg regclass;
BEGIN
  SELECT data_type INTO current_type
  FROM information_schema.columns
  WHERE table_schema = 'public'
    AND table_name = 'leads_lead'
    AND column_name = 'id';
  
  IF current_type = 'integer' THEN
    -- Convert leads_lead.id to bigint
    ALTER TABLE leads_lead
      ALTER COLUMN id TYPE bigint USING id::bigint;
    
    -- Update any sequence if it exists
    SELECT pg_get_serial_sequence('leads_lead', 'id') INTO seq_name;
    IF seq_name IS NOT NULL THEN
      SELECT to_regclass(seq_name) INTO seq_reg;
      IF seq_reg IS NOT NULL THEN
        EXECUTE format('ALTER SEQUENCE %s AS bigint', seq_reg);
      END IF;
    END IF;
    
    RAISE NOTICE 'Converted leads_lead.id from integer to bigint';
  ELSE
    RAISE NOTICE 'leads_lead.id is already % (no conversion needed)', current_type;
  END IF;
END $$;

COMMIT;

