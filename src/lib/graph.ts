// Microsoft Graph API utility for creating Teams meetings
// Usage: createTeamsMeeting(accessToken, meetingDetails)

import { IPublicClientApplication, InteractionRequiredAuthError } from '@azure/msal-browser';

// Utility function to get access token with fallback
export async function getAccessTokenWithFallback(
  instance: IPublicClientApplication,
  loginRequest: any,
  account: any,
  onInteractiveAuth?: () => void
): Promise<string | null> {
  try {
    // Try silent token acquisition first
    const response = await instance.acquireTokenSilent({
      ...loginRequest,
      account,
    });
    return response.accessToken;
  } catch (error) {
    console.log('Silent token acquisition failed, trying interactive:', error);
    try {
      // If silent acquisition fails, try interactive popup
      console.log('Opening Microsoft authentication popup...');
      if (onInteractiveAuth) {
        onInteractiveAuth();
      }
      const response = await instance.acquireTokenPopup(loginRequest);
      console.log('Interactive authentication successful');
      return response.accessToken;
    } catch (popupError) {
      console.error('Interactive token acquisition also failed:', popupError);
      if (popupError instanceof Error) {
        console.error('Error details:', popupError.message);
      }
      return null;
    }
  }
}

export async function createTeamsMeeting(accessToken: string, meetingDetails: {
  subject: string;
  startDateTime: string; // ISO string
  endDateTime: string;   // ISO string
  manager?: string;
  helper?: string;
  brief?: string;
  attendance_probability?: string;
  complexity?: string;
  car_number?: string;
  expert?: string;
  amount?: number;
  currency?: string;
}) {
  // Create meeting in potential clients calendar instead of personal calendar
  const potentialClientsCalendarEmail = 'shared-potentialclients@lawoffice.org.il';
  const url = `https://graph.microsoft.com/v1.0/users/${encodeURIComponent(potentialClientsCalendarEmail)}/calendar/events`;
  
  // Create detailed description with meeting information
  const description = [
    'Meeting Details:',
    `Manager: ${meetingDetails.manager || 'Not specified'}`,
    `Helper: ${meetingDetails.helper || 'Not specified'}`,
    `Expert: ${meetingDetails.expert || 'Not specified'}`,
    `Amount: ${meetingDetails.currency || 'â‚ª'}${meetingDetails.amount || 0}`,
    `Attendance Probability: ${meetingDetails.attendance_probability || 'Not specified'}`,
    `Complexity: ${meetingDetails.complexity || 'Not specified'}`,
    meetingDetails.car_number ? `Car Number: ${meetingDetails.car_number}` : '',
    meetingDetails.brief ? `Brief: ${meetingDetails.brief}` : '',
    '',
    'Generated by RMQ 2.0 System'
  ].filter(line => line !== '').join('\n');

  const body = {
    subject: meetingDetails.subject,
    start: {
      dateTime: meetingDetails.startDateTime,
      timeZone: 'UTC'
    },
    end: {
      dateTime: meetingDetails.endDateTime,
      timeZone: 'UTC'
    },
    body: {
      contentType: 'text',
      content: description
    },
    // Removed attendees to prevent automatic email invitations
    // attendees: (meetingDetails.attendees || []).map(a => ({
    //   emailAddress: {
    //     address: a.email
    //   },
    //   type: 'required'
    // })),
    isOnlineMeeting: true,
    onlineMeetingProvider: 'teamsForBusiness'
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const error = await response.json();
    console.error('Teams meeting creation error:', error);
    throw new Error(error.error?.message || 'Failed to create Teams meeting');
  }

  const data = await response.json();
  
  // Return the online meeting URL if available, otherwise the join URL
  return {
    joinUrl: data.onlineMeeting?.joinUrl || data.webLink,
    id: data.id,
    onlineMeeting: data.onlineMeeting
  };
}

export async function createStaffTeamsMeeting(
  accessToken: string,
  meetingDetails: {
    subject: string;
    startDateTime: string;
    endDateTime: string;
    attendees?: { email: string }[];
    isRecurring?: boolean;
    recurrencePattern?: 'daily' | 'weekly' | 'monthly';
    recurrenceInterval?: number;
    recurrenceEndDate?: string | null;
  }
) {
  // Create meeting in staff calendar
  const staffCalendarEmail = 'shared-staffcalendar@lawoffice.org.il';
  const url = `https://graph.microsoft.com/v1.0/users/${encodeURIComponent(staffCalendarEmail)}/calendar/events`;
  
  const body: any = {
    subject: meetingDetails.subject,
    start: {
      dateTime: meetingDetails.startDateTime,
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
    },
    end: {
      dateTime: meetingDetails.endDateTime,
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
    },
    // Removed attendees to prevent automatic email invitations
    // attendees: (meetingDetails.attendees || []).map(a => ({
    //   emailAddress: {
    //     address: a.email
    //   },
    //   type: 'required'
    // })),
    isOnlineMeeting: true,
    onlineMeetingProvider: 'teamsForBusiness'
  };

  // Add recurrence if specified
  if (meetingDetails.isRecurring) {
    const startDate = new Date(meetingDetails.startDateTime);
    const dayOfWeek = startDate.getDay(); // 0 = Sunday, 1 = Monday, etc.
    
    // Map JavaScript day numbers to Microsoft Graph day names
    const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
    const dayOfWeekName = dayNames[dayOfWeek];
    
    const recurrence: any = {
      pattern: {
        type: meetingDetails.recurrencePattern || 'weekly',
        interval: meetingDetails.recurrenceInterval || 1
      },
      range: {
        type: meetingDetails.recurrenceEndDate ? 'endDate' : 'noEnd',
        startDate: meetingDetails.startDateTime.split('T')[0],
        ...(meetingDetails.recurrenceEndDate && {
          endDate: meetingDetails.recurrenceEndDate.split('T')[0]
        })
      }
    };

    // Add daysOfWeek for weekly pattern
    if (meetingDetails.recurrencePattern === 'weekly') {
      recurrence.pattern.daysOfWeek = [dayOfWeekName];
    }
    
    // Add dayOfMonth for monthly pattern
    if (meetingDetails.recurrencePattern === 'monthly') {
      recurrence.pattern.dayOfMonth = startDate.getDate();
    }

    body.recurrence = recurrence;
  }


  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || `Failed to create Staff Teams meeting: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();
  
  // Return the online meeting URL if available, otherwise the join URL
  const result = {
    joinUrl: data.onlineMeeting?.joinUrl || data.webLink,
    id: data.id,
    onlineMeeting: data.onlineMeeting
  };
  
  return result;
}

// Teams Calling Functions
export async function initiateTeamsCall(accessToken: string, targetUserId: string, callType: 'audio' | 'video' = 'audio') {
  const url = 'https://graph.microsoft.com/v1.0/communications/calls';
  const body = {
    '@odata.type': '#microsoft.graph.call',
    callbackUri: `${window.location.origin}/api/callbacks`,
    targets: [
      {
        '@odata.type': '#microsoft.graph.invitationParticipantInfo',
        identity: {
          '@odata.type': '#microsoft.graph.identitySet',
          user: {
            '@odata.type': '#microsoft.graph.identity',
            id: targetUserId
          }
        }
      }
    ],
    requestedModalities: [callType],
    tenantId: import.meta.env.VITE_MSAL_TENANT_ID
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || 'Failed to initiate Teams call');
  }

  return await response.json();
}

export async function getCallStatus(accessToken: string, callId: string) {
  const url = `https://graph.microsoft.com/v1.0/communications/calls/${callId}`;
  
  const response = await fetch(url, {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || 'Failed to get call status');
  }

  return await response.json();
}

export async function answerCall(accessToken: string, callId: string) {
  const url = `https://graph.microsoft.com/v1.0/communications/calls/${callId}/answer`;
  const body = {
    callbackUri: `${window.location.origin}/api/callbacks`,
    acceptedModalities: ['audio', 'video']
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || 'Failed to answer call');
  }

  return await response.json();
}

export async function rejectCall(accessToken: string, callId: string) {
  const url = `https://graph.microsoft.com/v1.0/communications/calls/${callId}/reject`;
  const body = {
    reason: 'busy'
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || 'Failed to reject call');
  }

  return await response.json();
}

export async function endCall(accessToken: string, callId: string) {
  const url = `https://graph.microsoft.com/v1.0/communications/calls/${callId}`;
  
  const response = await fetch(url, {
    method: 'DELETE',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    }
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || 'Failed to end call');
  }

  return { success: true };
}

export async function muteCall(accessToken: string, callId: string, isMuted: boolean) {
  const url = `https://graph.microsoft.com/v1.0/communications/calls/${callId}/updateRecordingStatus`;
  const body = {
    isMuted: isMuted
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || 'Failed to update mute status');
  }

  return await response.json();
}

export const sendEmail = async (accessToken: string, email: {
  to: string | string[];
  subject: string;
  body: string;
  skipSignature?: boolean;
  cc?: string[];
}) => {
  // Get the user's email signature from the database
  const { getCurrentUserEmailSignature } = await import('./emailSignature');
  const userSignature = await getCurrentUserEmailSignature();
  
  let fullBody = email.body;
  
  // If we have a database signature, use it (unless explicitly skipped)
  if (!email.skipSignature && userSignature) {
    // Check if signature is already HTML
    if (userSignature.includes('<') && userSignature.includes('>')) {
      fullBody = email.body + `<br><br>${userSignature}`;
    } else {
      // Convert plain text to HTML
      const signatureHtml = `<br><br>${userSignature.replace(/\n/g, '<br>')}`;
      fullBody = email.body + signatureHtml;
    }
  }
  // If no database signature and not skipped, let Outlook add its automatic signature

  const normaliseRecipients = (value: string | string[] | undefined) => {
    if (!value) return [] as string[];
    if (Array.isArray(value)) {
      return value
        .map(recipient => recipient.trim())
        .filter(recipient => recipient.length > 0);
    }
    return value.trim().length > 0 ? [value.trim()] : [];
  };

  const toRecipients = normaliseRecipients(email.to);
  if (toRecipients.length === 0) {
    throw new Error('No recipient specified for the email.');
  }

  const ccRecipients = normaliseRecipients(email.cc);

  const emailToSend = {
    message: {
      subject: email.subject,
      body: {
        contentType: 'HTML',
        content: fullBody,
      },
      toRecipients: toRecipients.map(address => ({
        emailAddress: { address },
      })),
      ...(ccRecipients.length > 0
        ? {
            ccRecipients: ccRecipients.map(address => ({
              emailAddress: { address },
            })),
          }
        : {}),
    },
    saveToSentItems: 'true',
  };

  const response = await fetch('https://graph.microsoft.com/v1.0/me/sendMail', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(emailToSend),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Graph API error sending email: ${error.error.message}`);
  }

  // sendMail does not return content, a 202 Accepted status is success
  return { status: response.status };
}; 